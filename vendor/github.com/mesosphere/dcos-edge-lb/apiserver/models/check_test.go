package models

import (
	"fmt"
	"runtime/debug"
	"testing"
)

// XXX Need to figure out how to test validation that is done by the go-swagger
// autogenerated code. For example, go-swagger code checks that enums
// are within certain types.

func TestCheckConfig(t *testing.T) {
	cfg := &V1Config{}
	rawCfg := `
{
	"pools": [
		{ "name": "p" },
		{ "name": "p" }
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckConfig(cfg), failCheck("duplicate pool.name: p"))

	cfg = &V1Config{}
	rawCfg = `
{
	"pools": [
		{ "name": "p1" },
		{ "name": "p2" }
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckConfig(cfg), nil)
}

func TestCheckPool(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{ "name": "" }
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failString("pool.name"))

	cfg = &V1Pool{}
	rawCfg = `
{ "name": "p" }
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), nil)
}

func TestCheckName(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{ "name": "n.n" }
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failCheck("pool.name: n.n invalid: did not match %s", nameRegex))

	cfg = &V1Pool{}
	rawCfg = `
{ "name": "-n" }
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failCheck("pool.name: -n invalid: did not match %s", nameRegex))

	cfg = &V1Pool{}
	rawCfg = `
{ "name": "n5n5-5n55nn--5n5-n5" }
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), nil)
}

func TestCheckNamespace(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{
	"name": "n",
	"namespace": "/n"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failCheck("pool.namespace: /n invalid: did not match %s", namespaceRegex))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "n",
	"namespace": "n/"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failCheck("pool.namespace: n/ invalid: did not match %s", namespaceRegex))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "n",
	"namespace": "n/-n"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), failCheck("pool.namespace: -n invalid: did not match %s", nameRegex))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "1-n",
	"namespace": "1-n/1-n"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), nil)

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "1-n",
	"namespace": ""
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, V1CheckPool(cfg), nil)
}

func TestCheckPoolBindPorts(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{
	"name": "p",
	"ports": [-1]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("invalid bindPort: -1"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"ports": [80, 80]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("duplicate bindPort: 80"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"haproxy": {
		"stats": {
			"bindPort": -2
		}
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("invalid bindPort: -2"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"haproxy": {
		"frontends": [
			{}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("invalid bindPort: -1"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"haproxy": {
		"frontends": [
			{
				"bindPort": -3
			}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("invalid bindPort: -3"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"haproxy": {
		"stats": {
			"bindPort": 80
		},
		"frontends": [
			{
				"bindPort": 80
			}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolBindPorts(cfg), failCheck("duplicate bindPort: 80"))
}

func TestCheckPoolSecrets(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{
	"name": "p",
	"secrets": [
		{
			"secret": "s"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolSecrets(cfg), failString("pool.secrets.file"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"secrets": [
		{
			"file": "f"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolSecrets(cfg), failString("pool.secrets.secret"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"secrets": [
		{
			"secret": "s",
			"file": "f"
		},
		{
			"secret": "s",
			"file": "f"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolSecrets(cfg), failCheck("duplicate secret name: s"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"secrets": [
		{
			"secret": "s1",
			"file": "f"
		},
		{
			"secret": "s2",
			"file": "f"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolSecrets(cfg), failCheck("duplicate secret file: f"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"secrets": [
		{
			"secret": "s1",
			"file": "f1"
		},
		{
			"secret": "s2",
			"file": "f2"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolSecrets(cfg), nil)
}

func TestCheckSecretFile(t *testing.T) {
	input := "/"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "/a/b/c"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "a/b/c"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "-a"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "_a"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = ""
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = ".a"
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "."
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = ".."
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "a."
	eqError(t, checkSecretFile(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, secretFileRegex)))

	input = "a-"
	eqError(t, checkSecretFile(input), nil)

	input = "a-a"
	eqError(t, checkSecretFile(input), nil)

	input = "a_"
	eqError(t, checkSecretFile(input), nil)

	input = "a_a"
	eqError(t, checkSecretFile(input), nil)

	input = "A"
	eqError(t, checkSecretFile(input), nil)

	input = "s"
	eqError(t, checkSecretFile(input), nil)
}

func TestCheckPoolVirtualNetworks(t *testing.T) {
	cfg := &V1Pool{}
	rawCfg := `
{
	"name": "p",
	"virtualNetworks": [
		{
			"labels": {}
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolVirtualNetworks(cfg), failString("pool.virtualNetworks.name"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"virtualNetworks": [
		{
			"name": "n"
		},
		{
			"name": "n"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolVirtualNetworks(cfg), failCheck("duplicate virtualNetwork name: n"))

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"virtualNetworks": [
		{
			"name": "n"
		},
		{
			"name": "d"
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolVirtualNetworks(cfg), nil)

	cfg = &V1Pool{}
	rawCfg = `
{
	"name": "p",
	"virtualNetworks": [
		{
			"name": "n",
                        "labels": {"key0": "val0", "key1": "val1"}
		}
	]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkPoolVirtualNetworks(cfg), nil)
}

func TestCheckCertificate(t *testing.T) {
	input := "a"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "/a"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "a/a"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$AUTOCERT/a"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$ENVFILE"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$SECRETS"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$ENVFILE/"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$SECRETS/"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$ENVFILE/a/b"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$SECRETS/a/b"
	eqError(t, checkCertificate(input), failCheck(fmt.Sprintf("%s invalid: did not match %s", input, certificateRegex)))

	input = "$AUTOCERT"
	eqError(t, checkCertificate(input), nil)

	input = "$ENVFILE/a"
	eqError(t, checkCertificate(input), nil)

	input = "$SECRETS/a"
	eqError(t, checkCertificate(input), nil)
}

func TestCheckHaproxy(t *testing.T) {
	cfg := &V1Haproxy{}
	rawCfg := `
{
	"frontends": [
			{
				"name": "fe"
			},
			{
				"name": "fe"
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("duplicate frontend.name: fe"))

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"frontends": [
			{
				"name": "frontend_0.0.0.0_80"
			},
			{
				"bindAddress": "0.0.0.0",
				"bindPort": 80
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("duplicate frontend.name: frontend_0.0.0.0_80"))

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"frontends": [
			{
				"bindAddress": "0.0.0.0",
				"bindPort": 80,
				"protocol": "HTTP"
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), nil)

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"backends": [
			{
				"name": "be"
			},
			{
				"name": "be"
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("duplicate backend.name: be"))
}

func TestCheckHaproxyFeBe(t *testing.T) {
	cfg := &V1Haproxy{}
	rawCfg := `
{
	"frontends": [
			{
				"name": "fe",
				"bindPort": 80,
				"protocol": "HTTP",
				"linkBackend": {
					"defaultBackend": "be"
				}
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("frontends refer to nonexistent backends: be"))

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"frontends": [
			{
				"name": "fe",
				"bindPort": 80,
				"protocol": "HTTP",
				"linkBackend": {
					"map": [
						{
							"backend": "linkbe",
							"hostEq": "hi"
						}
					]
				}
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("frontends refer to nonexistent backends: linkbe"))

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"backends": [
			{
				"name": "be",
				"protocol": "HTTP",
				"servers": [{
					"type": "VIP",
					"framework": {"value": "f"},
					"task": {"value": "t"},
					"port": {"vip": "/vip:80"}
				}]
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), failCheck("frontends do not refer to these backends: be"))

	cfg = &V1Haproxy{}
	rawCfg = `
{
	"frontends": [
			{
				"name": "fe",
				"bindPort": 80,
				"protocol": "HTTP",
				"linkBackend": {
					"defaultBackend": "be",
					"map": [
						{
							"backend": "linkbe",
							"hostEq": "hi"
						}
					]
				}
			}
		],
	"backends": [
			{
				"name": "be",
				"protocol": "HTTP",
				"servers": [{
					"type": "VIP",
					"framework": {"value": "f"},
					"task": {"value": "t"},
					"port": {"vip": "/vip:80"}
				}]
			},
			{
				"name": "linkbe",
				"protocol": "HTTP",
				"servers": [{
					"type": "VIP",
					"framework": {"value": "f"},
					"task": {"value": "t"},
					"port": {"vip": "/vip:80"}
				}]
			}
		]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkHaproxy(cfg), nil)
}

func TestCheckFrontendBindAddress(t *testing.T) {
	cfg := &V1Frontend{}
	rawCfg := `
{
	"bindAddress": "*"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.bindAddress invalid character: '*'"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindAddress": "["
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.bindAddress invalid character: '['"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindAddress": "]"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.bindAddress invalid character: ']'"))
}

func TestCheckFrontend(t *testing.T) {
	cfg := &V1Frontend{}
	rawCfg := `
{
	"bindPort": 80
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failString("frontend.protocol"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "HTTPS"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.protocol HTTPS must have non-empty frontend.certificates"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "TCP",
	"redirectToHttps": {}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.redirectToHttps cannot be set with frontend.protocol TCP"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "TLS"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.protocol TLS must have non-empty frontend.certificates"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "HTTPS",
	"certificates": ["$AUTOCERT"]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), nil)

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "TLS",
	"certificates": ["$AUTOCERT"]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), nil)

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "HTTP"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), nil)

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "TCP"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), nil)
}

func TestCheckFrontendLinkBackend(t *testing.T) {
	cfg := &V1Frontend{}
	rawCfg := `
{
	"bindPort": 80,
	"protocol": "HTTP",
	"linkBackend": {
		"map": [
			{
			}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failString("frontend.linkBackend.map.backend"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "HTTP",
	"linkBackend": {
		"map": [
			{
				"backend": "be"
			}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), failCheck("frontend.linkBackend.map.backend: at least one of the condition fields must be filled out"))

	cfg = &V1Frontend{}
	rawCfg = `
{
	"bindPort": 80,
	"protocol": "HTTP",
	"redirectToHttps": {
		"except": [
			{ "host": "hi" }
		]
	},
	"linkBackend": {
		"map": [
			{
				"backend": "be",
				"hostEq": "myhost"
			}
		]
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkFrontend(cfg), nil)
}

func TestCheckBackend(t *testing.T) {
	cfg := &V1Backend{}
	rawCfg := `
{
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), failString("backend.name"))

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), failString("backend.protocol"))

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP"
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), failCheck("backend.servers: must have at least 1"))

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), nil)
}

func TestCheckBackendRewriteHTTP(t *testing.T) {
	cfg := &V1Backend{}
	rawCfg := `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": { },
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), nil)

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": { "path": { } },
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), nil)

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": {
		"path": {
			"fromPath": "",
			"toPath": "/bar/"
		}
	},
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), failCheck("backend.rewriteHttp.path: fromPath '' toPath '/bar/' ending mismatch: either both end with '/' or neither end with '/'"))

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": {
		"path": {
			"fromPath": "/foo",
			"toPath": "/bar/"
		}
	},
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), failCheck("backend.rewriteHttp.path: fromPath '/foo' toPath '/bar/' ending mismatch: either both end with '/' or neither end with '/'"))

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": {
		"path": {
			"fromPath": "",
			"toPath": "/bar"
		}
	},
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), nil)

	cfg = &V1Backend{}
	rawCfg = `
{
	"name": "be",
	"protocol": "HTTP",
	"rewriteHttp": {
		"path": {
			"fromPath": "/",
			"toPath": "/bar/"
		}
	},
	"servers": [{
		"type": "VIP",
		"framework": {"value": "f"},
		"port": {"vip": "/vip:80"}
	}]
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkBackend(cfg), nil)
}

func TestCheckServer(t *testing.T) {
	cfg := &V1Server{}
	rawCfg := `
{
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServer(cfg), failString("server.framework.value"))

	cfg = &V1Server{}
	rawCfg = `
{
	"framework": {
		"value": "fw"
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServer(cfg), failString("server.task.value"))

	cfg = &V1Server{}
	rawCfg = `
{
	"type": "VIP",
	"framework": {
		"value": "fw"
	},
	"port": {
		"vip": "myvip"
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServer(cfg), nil)

	cfg = &V1Server{}
	rawCfg = `
{
	"type": "VIP",
	"framework": {
		"value": "fw"
	},
	"task": {
		"value": "tk"
	},
	"port": {
		"vip": "myvip"
	}
}
	`
	if err := cfg.UnmarshalJSON([]byte(rawCfg)); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServer(cfg), nil)
}

func TestCheckServerPort(t *testing.T) {
	// ServerPort does not seem to have a UnmarshalJSON, probably because
	// it doesn't have any default values.

	sharedCfg := `
{
	"framework": {
		"value": "fw"
	},
	"task": {
		"value": "tk"
	},
    "port": %s
}
	`

	cfg := &V1Server{}
	svType := V1ServerTypeAGENTIP
	rawCfg := `
{
}
	`
	if err := cfg.UnmarshalJSON([]byte(fmt.Sprintf(sharedCfg, rawCfg))); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServerPort(cfg.Port, svType), failCheck("server.port: at least one of the fields must be filled out"))

	cfg = &V1Server{}
	rawCfg = `
{
	"vip": "myvip"
}
	`
	if err := cfg.UnmarshalJSON([]byte(fmt.Sprintf(sharedCfg, rawCfg))); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServerPort(cfg.Port, V1ServerTypeAGENTIP), failCheck("server.type AGENT_IP must have non-empty port.name or true port.all"))

	cfg = &V1Server{}
	rawCfg = `
{
	"vip": "myvip"
}
	`
	if err := cfg.UnmarshalJSON([]byte(fmt.Sprintf(sharedCfg, rawCfg))); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServerPort(cfg.Port, V1ServerTypeCONTAINERIP), failCheck("server.type CONTAINER_IP must have non-empty port.name or true port.all"))

	cfg = &V1Server{}
	rawCfg = `
{
	"name": "myport"
}
	`
	if err := cfg.UnmarshalJSON([]byte(fmt.Sprintf(sharedCfg, rawCfg))); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServerPort(cfg.Port, V1ServerTypeVIP), failCheck("server.type VIP must have non-empty port.vip"))

	cfg = &V1Server{}
	rawCfg = `
{
	"name": "myport"
}
	`
	if err := cfg.UnmarshalJSON([]byte(fmt.Sprintf(sharedCfg, rawCfg))); err != nil {
		t.Fatal(err)
	}
	eqError(t, v1checkServerPort(cfg.Port, svType), nil)
}

func eqError(t *testing.T, e1, e2 error) {
	if e1 == nil && e2 == nil {
		return
	}

	if (e1 == nil && e2 != nil) ||
		(e1 != nil && e2 == nil) ||
		(e1.Error() != e2.Error()) {
		t.Errorf("\ngot:      %v\nexpected: %v\n%s", e1, e2, string(debug.Stack()))
	}
}
